Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'part 3' stamp: 'BM 12/12/2020 21:58'!isKindOf: aClassOrInterface	^((super isKindOf: aClassOrInterface) or: [self class behavesLike: aClassOrInterface]).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'part 1' stamp: 'BM 12/10/2020 20:30'!compile: aSourceCode	| num_arguments dummy_constraints |	"Re-wire compile: to go through compile:where:"		num_arguments := (Parser new parse: aSourceCode class: MyObject) arguments size.	dummy_constraints := OrderedCollection new.	1 to: num_arguments do: [:i | dummy_constraints add: nil].	^self compile: aSourceCode where: dummy_constraints.! !!MyObject class methodsFor: 'part 1' stamp: 'BM 12/10/2020 20:25'!compile: aSourceCode where: anOrderedCollection	| method args lines pre_body arg_check body |		"create new source code to check argument constraints"		method := (Parser new parse: aSourceCode class: MyObject).	args := method arguments collect: [:each | each name].	arg_check := (self constrain: anOrderedCollection parameters: args).		"split original source code into two parts - everything before the body, and the body itself"	lines := aSourceCode findBetweenSubStrs: (String cr).	((lines size >= 2) and: [(lines at: 2) withoutLeadingBlanks beginsWith: '|']) ifTrue: [		pre_body := self joinStrings: (lines collect: [:x | x] from: 1 to: 2).		body := self joinStrings: (lines collect: [:x | x] from: 3 to: (lines size)).	] ifFalse: [		pre_body := self joinStrings: (lines collect: [:x | x] from: 1 to: 1).		body := self joinStrings: (lines collect: [:x | x] from: 2 to: (lines size)).	].	"prevent interfaces from defining non-empty non-default methods"	(self isInterface			and: [(self isDefaultMethod: aSourceCode) not]			and: [(body withoutLeadingBlanks size) > 0]) ifTrue: [		AssertionFailure signal: 'Interfaces are not allowed to have methods that define behavior!!'	].	^super compile: (pre_body , arg_check , body).! !!MyObject class methodsFor: 'part 1' stamp: 'BM 12/9/2020 13:39'!compile: aSourceCode where: anOrderedCollection old: aBool	|source first_row splitted_code classes_size class  var err1 err2s err2e is_local_varb|		Transcript show: ((Parser new parse: 'foo' class: MyObject) class); cr.		err1 := 'Can not compile method, number of arguments is not equal to the number of constraints!!'.	err2s := 'ifFalse: [AssertionFailure signal: ''Type mismatch!! Argument  '.	err2e := ' should be '.				classes_size:=  anOrderedCollection size.	splitted_code := aSourceCode  findBetweenSubStrs: (String cr).		"splitting first row into array."		first_row:= ((aSourceCode findBetweenSubStrs: (String cr)) first).	first_row := first_row findBetweenSubStrs: (':').	(classes_size + 1 = first_row size)	ifFalse:[AssertionFailure signal: err1].		source := splitted_code first.	source := source, String cr.		"checking if second row contain variable"	is_local_varb := 0.	(((splitted_code at:2)  findString:'|')>0)	ifTrue: [		is_local_varb:= 1.		source := source, (splitted_code at: 2), (String cr)	]. 		"adding assert kindOf to source code and compile"		(1 to: classes_size by: 1) do: [:i |		 var:= ((first_row  at: i + 1 ) findBetweenSubStrs: ( ' ' )) first.		class := anOrderedCollection at: i.		(class == nil)		ifFalse:[source := source, '(' , var, ' isKindOf: ' , class, ')', String cr, err2s, i, err2e, class, '''].', String cr].	].	 	((2 + is_local_varb) to: (splitted_code size)) do: [:i | source := source, (splitted_code at: i ), String cr].	self compile:source! !!MyObject class methodsFor: 'part 1' stamp: 'BM 12/9/2020 15:58'!constrain: orderedConstraints parameters: orderedArgumentNames	"Return source code that checks if each argument meets its constraint.	The returned string is meant to be injected into a compiled source."	| result |	(orderedConstraints size = orderedArgumentNames size) ifFalse: [AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!'].	result := ''.	1 to: (orderedConstraints size) do: [:i | | arg constraint |		((orderedConstraints at: i) ~= nil) ifTrue: [			arg := orderedArgumentNames at: i.			constraint := (orderedConstraints at: i).			"We need to add line of this format:			({arg} isKindOf: {constraint}) ifFalse: [AssertionFailure signal: 'Type mismatch!! Argument {i} should be {contraint}']."			result := result , '(' , arg , ' isKindOf: ' , constraint , ') ifFalse: [AssertionFailure signal: ''Type mismatch!! Argument ' , (i asString) , ' should be ' , constraint , '''].' , (String cr).		]	].	^result! !!MyObject class methodsFor: 'part 1' stamp: 'BM 12/9/2020 15:26'!joinStrings: strings	"Join an order collection of strings into a single string."	^strings inject: '' into: [:acc :each | acc , each].! !!MyObject class methodsFor: 'part 3' stamp: 'BM 12/13/2020 11:16'!injectDefaultMethods	"Inject into self all the default methods defined in classes it behaves like."	self behavesLike do: [:interface |		interface definedMethods			select: [:each | each beginsWith: 'default']			thenDo: [:method | self injectMethod: method from: interface]	].! !!MyObject class methodsFor: 'part 3' stamp: 'BM 12/13/2020 11:28'!injectMethod: aMethodName from: aClass	"Inject into self a method defined in aClass.	The method is injected into self by compiling a new method into self.	The new method	creates a new instance of aClass, then invokes its method and returns the result."	| selector new_code |	selector := (aClass methodDict at: aMethodName) selector.	(selector endsWith: ':') ifTrue: [		"Method has arguments. Assume it only has one, an Integer."		"TODO: do we need to include type checking via compile:where:?"		"New code: 'foo: x\n^(aClass privateNew) foo: x'"		"We use privateNew instead of new, to by-pass abstractness/interfaceness restrictions.		This is okay, because the instance is not visible outside of the method."		new_code := '' , selector , ' x' , (String cr) , '^(' , aClass , ' privateNew) ' , selector , ' x'.	] ifFalse: [		"Methtod has 0 argument"		"New code: 'foo\n^(aClass privateNew) foo'"		new_code := '' , selector , (String cr) , '^(' , aClass , ' privateNew) ' , selector	].	self compile: new_code.! !!MyObject class methodsFor: 'part 3' stamp: 'BM 12/12/2020 21:53'!isAbstract	^(self behavesLike allSatisfy: [:any | any isImplementedBy: self]) not! !!MyObject class methodsFor: 'part 3' stamp: 'BM 12/13/2020 11:03'!privateNew	"Create a new object, by-passing restrictions. For internal use only.	For invoking a default method, we need an actual instances of the defining interface, hence this function."	^(super new).! !!MyObject class methodsFor: 'part 2' stamp: 'BM 12/11/2020 11:00'!ambiguities	| methods |	"A bag is actually a set that allows multiplicities, and keeps count how many times each	item occurres in the set."	methods := Bag new.	self behavesLike do: [:interface | methods addAll: (interface definedMethods)].	"A method causes ambiguity if it is defined in at least 2 interfaces whom self behaves like. 	These are exactly the methods that appear at least twice in the bag."	"Naming is misleading here - valuesAndCounts returns a dictionary. The keys of the dictionary are	the values (items) of the bag, and the values of the dictionary are the counts of the bag."	^SortedCollection newFrom: ((methods valuesAndCounts select: [:count | count > 1]) keys)! !!MyObject class methodsFor: 'part 2' stamp: 'BM 12/9/2020 19:28'!behavesLike	^behavesLike"	| result |	(self = MyObject) ifTrue: [^behavesLike].	result := Set new.	(self isInterface) ifTrue: [result add: self].	result addAll: behavesLike.	result addAll: (self superclass behavesLike).	behavesLike do: [:each | result addAll: each behavesLike].	^result"! !!MyObject class methodsFor: 'part 2' stamp: 'BM 12/9/2020 18:20'!behavesLike: anInterface	"Return true if self behaves like anInterface"	^behavesLike includes: anInterface.! !!MyObject class methodsFor: 'part 2' stamp: 'BM 12/11/2020 10:59'!definedMethods	"Return all methods defined by self.	Does not include methods defined in other classes/interfaces that self derives from/behaves like."	(self = MyObject) ifTrue: [^Set new].	^Set newFrom: (self methodDict keys)	! !!MyObject class methodsFor: 'part 2' stamp: 'BM 12/18/2020 12:36'!implementsMethod: aSymbol	"Return true if self implements method whose name is aSymbol"	(self canUnderstand: aSymbol) ifTrue: [^true].	(self = MyObject) ifTrue: [^false].	^superclass implementsMethod: aSymbol! !!MyObject class methodsFor: 'part 2' stamp: 'BM 12/9/2020 22:19'!interfaceMethods	"Return all interface methods for self.	An interface method is a method defined in an interface that self behaves like."	| result |	(self = MyObject) ifTrue: [^Set new].	result := Set new.	(behavesLike select: [:each | each isInterface])		do: [:each | result addAll: each methodDict keys].	^result.	! !!MyObject class methodsFor: 'part 2' stamp: 'BM 12/9/2020 17:08'!isDefaultMethod: aSourceCode	"Return true if aSourceCode defines a default method"	^aSourceCode withoutLeadingBlanks beginsWith: 'default'! !!MyObject class methodsFor: 'part 2' stamp: 'BM 12/18/2020 12:44'!isImplemented	(self isInterface) ifFalse: [AssertionFailure signal: ('' , self , ' is not an interface!!')].	^MyObject allSubclasses anySatisfy: [:any | (any isInterface not) and: [self isImplementedBy: any]]! !!MyObject class methodsFor: 'part 2' stamp: 'BM 12/9/2020 18:30'!isImplementedBy: aClass	"Return true if aClass implements self"	(aClass behavesLike: self) ifFalse: [^false].	"`x allSatisfy: y` returns true when x is empty"	^self nonDefaultMethods allSatisfy: [:each | aClass implementsMethod: each]! !!MyObject class methodsFor: 'part 2' stamp: 'BM 12/10/2020 19:54'!isInterface 	^(self ~= MyObject) and: [isInterface]! !!MyObject class methodsFor: 'part 2' stamp: 'BM 12/9/2020 22:46'!new	(self isInterface) ifTrue: [AssertionFailure signal: 'Interfaces can not be instantiated!!'].	(self isAbstract) ifTrue: [AssertionFailure signal:  'Can not instantiate an Abstract class!!'].	^(super new).! !!MyObject class methodsFor: 'part 2' stamp: 'BM 12/9/2020 19:02'!nonDefaultMethods	"Return all non-default methods of self"	^self interfaceMethods reject: [:each | each beginsWith: 'default']	! !!MyObject class methodsFor: 'part 2' stamp: 'OF 12/7/2020 19:16'!subclass: aSymbol instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryName|aCollection isInterface|isInterface := false.aCollection := Set new.^ (self subclass: aSymbol isInterface: isInterface behavesLike: aCollectioninstanceVariableNames: instVarNames classVariableNames: classVarNamespoolDictionaries: poolDictionaries category: aCategoryName).! !!MyObject class methodsFor: 'part 2' stamp: 'BM 12/13/2020 11:20'!subclass: aSymbol isInterface: isInterface behavesLike: aCollectioninstanceVariableNames: instVarNames classVariableNames: classVarNamespoolDictionaries: poolDictionaries category: aCategoryName	| err2_1 err2_2 err2_3 err2_4 new_class behaver_like |		"handling errors"		err2_1:= 'Interfaces must derive from MyObject!!'.	err2_2:= 'Interfaces can not have state!!'.	err2_3:= 'Classes can not derive from an interface!!'.	err2_4:= 'Can not behave like a non-interface!!'.	(((self isMemberOf: MyObject class) not) and: isInterface)		 ifTrue: [ AssertionFailure signal: err2_1 ].  		(((instVarNames isEmpty) not)  and:( isInterface))		 ifTrue: [ AssertionFailure signal:err2_2 ]. 		(self isMemberOf: (MyObject class))		ifFalse: [((isInterface not)  and:  self isInterface)  ifTrue: [AssertionFailure signal: err2_3 ]].		aCollection do: [:inter | (inter isInterface) ifFalse: [ AssertionFailure signal: err2_4] ].		"creating class" 	new_class := (super subclass: aSymbol instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: 	poolDictionaries category: aCategoryName).	new_class instVarNamed: 'isInterface' put: isInterface.		behaver_like := Set new.	aCollection do: [:inter | 		behaver_like add: inter.		(inter behavesLike) do:[:each | behaver_like add: each.].	].		((self isKindOf: (MyObject class)) and: (self isMemberOf: (MyObject class)) not )	ifTrue: [(self behavesLike) do: [:inter |			behaver_like add: inter. ]].	(isInterface)	ifTrue: [behaver_like add: new_class].			new_class instVarNamed: 'behavesLike' put: behaver_like.		(new_class isInterface) ifFalse: [new_class injectDefaultMethods].		^ new_class	! !