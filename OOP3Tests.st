TestCase subclass: #OOP3TestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3Tests'!!OOP3TestCase methodsFor: 'testing' stamp: 'BM 12/10/2020 16:36'!assertError: aBlock message: aString	"Execute a block (aBlock) and assert that it raises an error with correct message."	| message |	self assert: ([aBlock value. false] on: AssertionFailure do: [:error | message := (error messageText). true])		description: 'expected error'.	self assert: (message = aString) description: ('wrong error message: "' , message , '"').! !OOP3TestCase subclass: #Part1Test	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3Tests'!!Part1Test methodsFor: 'as yet unclassified' stamp: 'BM 12/9/2020 13:33'!setUp	MyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	A subclass: #B instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.! !!Part1Test methodsFor: 'as yet unclassified' stamp: 'BM 12/9/2020 15:43'!test1	"this test is problematic, because B may be leftover from a previous test run."	"	self assert: 0 equals: (B methodDict size).	B compile: 'foo'.	self assert: 1 equals: (B methodDict size).	B compile: 'foo: a' where: #(Integer).	self assert: 2 equals: (B methodDict size).	"! !!Part1Test methodsFor: 'as yet unclassified' stamp: 'EK 12/21/2021 20:34'!test2	| method_count |	B compile: 'bar' where: #().	method_count := B methodDict size.	self assertError:  [B compile: 'foo: a' where: #()] message: 'Can not compile method, number of arguments is not equal to the number of constraints!!'.	self assert: method_count equals: B methodDict size.		Transcript show: 'SUCCESS2'; cr.! !!Part1Test methodsFor: 'as yet unclassified' stamp: 'EK 12/21/2021 20:34'!test3	| b |	B compile: 'foo: a' where: #(Integer).	b := B new.	self assert: (b == (b foo: 1)).		Transcript show: 'SUCCESS3'; cr.! !!Part1Test methodsFor: 'as yet unclassified' stamp: 'EK 12/21/2021 20:34'!test4	| b source |	source := 'foo: a bar:b baz:  c	| var1 |		var1 := a + c.	" just a comment, nothing special "		^ (var1 * var1)'.	B compile: source where: #(Integer nil Number).	b := B new.	self assert: (16 == (b foo: 1 bar: 2 baz: 3)).		Transcript show: 'SUCCESS4'; cr.! !!Part1Test methodsFor: 'as yet unclassified' stamp: 'EK 12/21/2021 20:34'!test5	| b |	B compile: 'foo: a' where: #(Integer).	b := B new.	self assertError: [b foo: '1'] message: 'Type mismatch!! Argument 1 should be Integer'.		Transcript show: 'SUCCESS5'; cr.! !!Part1Test methodsFor: 'as yet unclassified' stamp: 'EK 12/21/2021 20:34'!test6	| b source |	source := 'foo: a bar:b baz:  c	| var1 |		var1 := a + c.	" just a comment, nothing special "		^ (var1 * var1)'.	B compile: source where: #(Integer nil Number).	b := B new.	self assertError: [b foo: 1 bar: 2 baz: '3'] message: 'Type mismatch!! Argument 3 should be Number'.		Transcript show: 'SUCCESS6'; cr.! !!Part1Test methodsFor: 'as yet unclassified' stamp: 'EK 12/21/2021 20:34'!test7	B compile: 'foo' where: #().	B compile: 'foo: a' where: #(nil).	B compile: 'foo: a bar: b' where: #(nil nil).	B compile: 'foo: a bar: b baz: c' where: #(nil nil nil).	B compile: 'goo' where: #().	B compile: 'goo: a' where: #(MyObject).	B compile: 'goo: a bar: b' where: #(MyObject MyObject).	B compile: 'goo: a bar: b baz: c' where: #(MyObject MyObject MyObject).		Transcript show: 'SUCCESS7'; cr.! !OOP3TestCase subclass: #Part2Test	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3Tests'!!Part2Test methodsFor: 'method3' stamp: 'BM 12/10/2020 16:08'!test3_1	self make: MyObject subclass: #Test3_1 like: {}.	self makeInterface: #ITest3_1 like: {}.	self make: MyObject subclass: #Test3_2 like: {ITest3_1}.			self assert: Test3_1 isInterface not.	self assert: ITest3_1 isInterface.	self assert: Test3_2 isInterface not.! !!Part2Test methodsFor: 'method3' stamp: 'BM 12/10/2020 17:13'!test3_2	self assert: false equals: MyObject isInterface.! !!Part2Test methodsFor: 'method1' stamp: 'BM 12/10/2020 15:49'!test1_1	| retval |	retval := MyObject subclass: #Test1_1 isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	self assert: Test1_1 equals: retval.		retval := MyObject subclass: #ITest1_1 isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	self assert: ITest1_1 equals: retval.		retval := MyObject subclass: #ITest1_2 isInterface: true behavesLike: {ITest1_1} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	self assert: ITest1_2 equals: retval.	retval := MyObject subclass: #Test1_2 isInterface: false behavesLike: {ITest1_2} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	self assert: Test1_2 equals: retval.	retval := MyObject subclass: #ITest1_3 isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	self assert: ITest1_3 equals: retval.	retval := MyObject subclass: #Test1_3 isInterface: false behavesLike: {ITest1_1 . ITest1_2 . ITest1_3} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	self assert: Test1_3 equals: retval.! !!Part2Test methodsFor: 'method1' stamp: 'BM 12/11/2020 11:27'!test1_2	MyObject subclass: #Test1_2_1 isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	self assertError: [Test1_2_1 subclass: #ITest1_2_1 isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3']		message: 'Interfaces must derive from MyObject!!'.			self assertError: [MyObject subclass: #ITest1_2_2 isInterface: true behavesLike: {} instanceVariableNames: 'foo' classVariableNames: '' poolDictionaries: '' category: 'OOP3']		message: 'Interfaces can not have state!!'.		"class variables are not considered as state, so this should NOT throw an error."	MyObject subclass: #ITest1_2_3 isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: 'Foo' poolDictionaries: '' category: 'OOP3'.		MyObject subclass: #ITest1_2_4 isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	self assertError: [ITest1_2_4 subclass: #Test1_2_2 isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: 'Foo' poolDictionaries: '' category: 'OOP3']		message: 'Classes can not derive from an interface!!'.		"interface like myobject"	self assertError: [MyObject subclass: #ITest1_2_5 isInterface: true behavesLike: {ITest1_2_4 . MyObject} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3']		message: 'Can not behave like a non-interface!!'.			"class like myobject"	self assertError: [MyObject subclass: #Test1_2_3 isInterface: false behavesLike: {ITest1_2_4 . MyObject} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3']		message: 'Can not behave like a non-interface!!'.	MyObject subclass: #Test1_2_4 isInterface: false behavesLike: {ITest1_2_4} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.		"interface like class"	self assertError: [MyObject subclass: #ITest1_2_6 isInterface: true behavesLike: {ITest1_2_4 . Test1_2_4} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3']		message: 'Can not behave like a non-interface!!'.			"class like class"	self assertError: [MyObject subclass: #Test1_2_5 isInterface: false behavesLike: {ITest1_2_4 . Test1_2_4} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3']		message: 'Can not behave like a non-interface!!'.! !!Part2Test methodsFor: 'method1' stamp: 'BM 12/11/2020 10:38'!test1_3	"Test correct order of exceptions"	MyObject subclass: #Test1_3_1 isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	MyObject subclass: #ITest1_3_1 isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.		self assertError: [		Test1_3_1 subclass: #ITest1_3_2 isInterface: true behavesLike: {Test1_3_1} instanceVariableNames: 'foo' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	] message: 'Interfaces must derive from MyObject!!'.	self assertError: [		MyObject subclass: #ITest1_3_3 isInterface: true behavesLike: {Test1_3_1} instanceVariableNames: 'foo' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	] message: 'Interfaces can not have state!!'.		self assertError: [		MyObject subclass: #ITest1_3_4 isInterface: true behavesLike: {Test1_3_1} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	] message: 'Can not behave like a non-interface!!'.		self assertError: [		ITest1_3_1 subclass: #Test1_3_2 isInterface: false behavesLike: {Test1_3_1} instanceVariableNames: 'foo' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	] message: 'Classes can not derive from an interface!!'.	self assertError: [		MyObject subclass: #Test1_3_3 isInterface: false behavesLike: {Test1_3_1} instanceVariableNames: 'foo' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	] message: 'Can not behave like a non-interface!!'.! !!Part2Test methodsFor: 'method2' stamp: 'BM 12/10/2020 15:53'!test2_1	| retval |	retval := MyObject subclass: #Test2_1 instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	self assert: Test2_1 equals: retval.		retval := MyObject subclass: #ITest2_1 isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	self assert: ITest2_1 equals: retval.		retval := MyObject subclass: #ITest2_2 isInterface: true behavesLike: {ITest2_1} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	self assert: ITest2_2 equals: retval.	retval := MyObject subclass: #Test2_2 instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	self assert: Test2_2 equals: retval.! !!Part2Test methodsFor: 'method2' stamp: 'BM 12/10/2020 16:05'!test2_2	self makeInterface: #ITest2_2_1 like: {}.	self makeInterface: #ITest2_2_2 like: {}.	self make: MyObject subclass: #Test2_2_1 like: {ITest2_2_1 . ITest2_2_2}.	Test2_2_1 subclass: #Test2_2_2 instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'. 	Test2_2_1 subclass: #Test2_2_3 isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'. 	self assert: (Test2_2_1 behavesLike includes: ITest2_2_1).	self assert: (Test2_2_1 behavesLike includes: ITest2_2_2).		self assert: (Test2_2_2 behavesLike includes: ITest2_2_1).	self assert: (Test2_2_2 behavesLike includes: ITest2_2_2).	self assert: (Test2_2_3 behavesLike includes: ITest2_2_1).	self assert: (Test2_2_3 behavesLike includes: ITest2_2_2).! !!Part2Test methodsFor: 'method4' stamp: 'BM 12/10/2020 16:28'!test4_1	self makeInterface: #ITest4_1_1 like: {}.	self assert: ITest4_1_1 behavesLike: {ITest4_1_1}.			self makeInterface: #ITest4_1_2 like: {ITest4_1_1}.	self makeInterface: #ITest4_1_3 like: {}.		self assert: ITest4_1_2 behavesLike: {ITest4_1_2 . ITest4_1_1}.	self assert: ITest4_1_3 behavesLike: {ITest4_1_3}.		self make: MyObject subclass: #Test4_1_1 like: {}.	self make: Test4_1_1 subclass: #Test4_1_2 like: {ITest4_1_2}.	self make: MyObject subclass: #Test4_1_3 like: {ITest4_1_1 . ITest4_1_3}.	self make: Test4_1_3 subclass: #Test4_1_4 like: {ITest4_1_2}.		self assert: Test4_1_1 behavesLike: {}.	self assert: Test4_1_2 behavesLike: {ITest4_1_2 . ITest4_1_1}.	self assert: Test4_1_3 behavesLike: {ITest4_1_3 . ITest4_1_1}.	self assert: Test4_1_4 behavesLike: {ITest4_1_3 . ITest4_1_2 . ITest4_1_1}.! !!Part2Test methodsFor: 'method6' stamp: 'BM 12/11/2020 11:05'!test6_1	self makeInterface: #ITest6_1_1 like: {}.	ITest6_1_1 compile: 'foo' ; compile: 'a' ; compile: 'foo: bar' ; compile: 'foo: fee baz: bee'.	self makeInterface: #ITest6_1_2 like: {}.	ITest6_1_2 compile: 'foo' ; compile: 'a' ; compile: 'foo: bar' ; compile: 'foo: fee baz: bee'.		self make: MyObject subclass:  #Test6_1_1 like: {ITest6_1_1 . ITest6_1_2}.	self assert: Test6_1_1 ambiguities: #(a foo foo: foo:baz:).		self makeInterface: #ITest6_1_3 like: {ITest6_1_1 . ITest6_1_2}.	self assert: ITest6_1_3 ambiguities: #(a foo foo: foo:baz:).! !!Part2Test methodsFor: 'method6' stamp: 'BM 12/11/2020 11:07'!test6_2	self makeInterface: #ITest6_2_1 like: {}.	ITest6_2_1 compile: 'foo' ; compile: 'a'.	self makeInterface: #ITest6_2_2 like: {}.	ITest6_2_2 compile: 'foo: bar' ; compile: 'foo: fee baz: bee'.		self make: MyObject subclass:  #Test6_2_1 like: {ITest6_2_1 . ITest6_2_2}.	self assert: Test6_2_1 ambiguities: #().		self makeInterface:  #ITest6_2_3 like: {ITest6_2_1 . ITest6_2_2}.	self assert: ITest6_2_3 ambiguities: #().! !!Part2Test methodsFor: 'method6' stamp: 'BM 12/11/2020 11:08'!test6_3	self makeInterface: #ITest6_3_1 like: {}.	ITest6_3_1 compile: 'foo' ; compile: 'a'.	self makeInterface: #ITest6_3_2 like: {ITest6_3_1}.	ITest6_3_2 compile: 'foo: bar' ; compile: 'foo: fee baz: bee'.		self make: MyObject subclass:  #Test6_3_1 like: {ITest6_3_2}.	self assert: Test6_3_1 ambiguities: #().	self make: MyObject subclass:  #Test6_3_2 like: {ITest6_3_1 . ITest6_3_2}.	self assert: Test6_3_2 ambiguities: #().		self makeInterface: #ITest6_3_3 like: {ITest6_3_2}.	self assert: ITest6_3_3 ambiguities: #().	self makeInterface: #ITest6_3_4 like: {ITest6_3_1 . ITest6_3_2}.	self assert: ITest6_3_4 ambiguities: #().! !!Part2Test methodsFor: 'method6' stamp: 'BM 12/11/2020 11:21'!test6_4	self makeInterface: #ITest6_4_1 like: {}.	ITest6_4_1 compile: 'foo' ; compile: 'a'.	self makeInterface: #ITest6_4_2 like: {}.	ITest6_4_2 compile: 'foo: bar' ; compile: 'a'.		self makeInterface: #ITest6_4_3 like: {ITest6_4_1}.	self makeInterface: #ITest6_4_4 like: {ITest6_4_2}.		self make: MyObject subclass: #Test6_4_1 like: {ITest6_4_3}.	self make: Test6_4_1 subclass: #Test6_4_2 like: {ITest6_4_4}.	self assert: Test6_4_1 ambiguities: #().	self assert: Test6_4_2 ambiguities: #(a).	self makeInterface: #ITest6_4_5 like: {ITest6_4_3 . ITest6_4_4}.	self assert: ITest6_4_5 ambiguities: #(a).! !!Part2Test methodsFor: 'method6' stamp: 'BM 12/11/2020 11:33'!test6_5	self makeInterface: #ITest6_5_1 like: {}.	ITest6_5_1 compile: 'foo'.	self makeInterface: #ITest6_5_2 like: {ITest6_5_1}.	ITest6_5_2 compile: 'foo'.		self assert: ITest6_5_1 ambiguities: #().	self assert: ITest6_5_2 ambiguities: #(foo).	! !!Part2Test methodsFor: 'method6' stamp: 'BM 12/11/2020 11:34'!test6_6	self makeInterface: #ITest6_6_1 like: {}.	ITest6_6_1 compile: 'foo'.	self makeInterface: #ITest6_6_2 like: {}.	ITest6_6_2 compile: 'foo'.		self make: MyObject subclass: #Test6_6_1 like: {ITest6_6_1}.	self make: Test6_6_1 subclass: #Test6_6_2 like: {ITest6_6_2}.		self assert: Test6_6_1 ambiguities: #().	self assert: Test6_6_2 ambiguities: #(foo).	! !!Part2Test methodsFor: 'method6' stamp: 'BM 12/11/2020 11:37'!test6_7	self makeInterface: #ITest6_7_1 like: {}.	ITest6_7_1 compile: 'foo'.	self make: MyObject subclass: #Test6_7_1 like: {ITest6_7_1}.	Test6_7_1 compile: 'foo	^ 42.' where: #().	self make: Test6_7_1 subclass: #Test6_7_2 like: {}.	self make: Test6_7_1 subclass: #Test6_7_3 like: {}.	Test6_7_3 compile: 'foo	^ 21.' where: #().		self assert: Test6_7_1 ambiguities: #().	self assert: Test6_7_2 ambiguities: #().	self assert: Test6_7_3 ambiguities: #().	! !!Part2Test methodsFor: 'method6' stamp: 'BM 12/11/2020 11:39'!test6_8	self makeInterface: #ITest6_8_1 like: {}.	ITest6_8_1 compile: 'foo'.	ITest6_8_1 compile: 'defaultFoo'.	self assert: ITest6_8_1 ambiguities: #().	self makeInterface: #ITest6_8_2 like: {}.	ITest6_8_2 compile: 'foo'.	self makeInterface: #ITest6_8_3 like: {}.	ITest6_8_3 compile: 'defaultFoo'.	self makeInterface: #ITest6_8_4 like: {ITest6_8_2 . ITest6_8_3}.	self assert: ITest6_8_4 ambiguities: #().! !!Part2Test methodsFor: 'method8' stamp: 'EK 12/21/2021 19:58'!test8_1	self makeInterface: #Itest8_1 like: {}.	Itest8_1 compile: 'foo' where: #().		self assertError: [Itest8_1 compile: 'bar		^0' where: #()] message: 'Interfaces are not allowed to have methods that define behavior!!'.		self assertError: [Itest8_1 compile: 'baz		^0'] message: 'Interfaces are not allowed to have methods that define behavior!!'.	! !!Part2Test methodsFor: 'method7' stamp: 'BM 12/10/2020 20:36'!test7_1	A new. "should succeed without error"	self assertError: [IA new] message: 'Interfaces can not be instantiated!!'.		self make: MyObject subclass: #Test7_1 like: {}.	self makeInterface: #ITest7_1 like: {}.	Test7_1 new.	self assertError: [ITest7_1 new] message: 'Interfaces can not be instantiated!!'.! !!Part2Test methodsFor: 'method5' stamp: 'BM 12/12/2020 21:36'!test5_1	self makeInterface: #I1test5_1 like: {}.	self makeInterface: #I2test5_1 like: {}.	self make: MyObject subclass: #Test5_1 like: {I1test5_1}.		I1test5_1 compile: 'foo'.	I2test5_1 compile: 'bar'.	Test5_1 compile: 'foo' where: #().		self assert: true equals:I1test5_1 isImplemented.	self assert: false equals: I2test5_1 isImplemented.! !!Part2Test methodsFor: 'method5' stamp: 'EK 12/21/2021 19:46'!test5_2	self makeInterface: #Itest5_2 like: {}.	self make: MyObject subclass: #Test5_2 like: {Itest5_2}.		Test5_2 compile: 'foo' where: #().		self assert: Itest5_2 isImplemented.! !!Part2Test methodsFor: 'method5' stamp: 'BM 12/11/2020 10:39'!test5_3	self make: MyObject subclass: #Test5_3 like: {}.	self assertError: [Test5_3 isImplemented] message: 'Test5_3 is not an interface!!'.! !!Part2Test methodsFor: 'as yet unclassified' stamp: 'BM 12/11/2020 10:51'!assert: aClassOrInterface ambiguities: aCollection	"Assert that aClassOrInterface has exactly the ambiguities listed in aCollection."	| sorted_ambigs actual_ambigs |		sorted_ambigs := SortedCollection newFrom: aCollection.	actual_ambigs := aClassOrInterface ambiguities.		self assert: (actual_ambigs isKindOf: SortedCollection).	self assert: (sorted_ambigs size) equals: (actual_ambigs size).	self assert: sorted_ambigs equals: actual_ambigs.! !!Part2Test methodsFor: 'as yet unclassified' stamp: 'BM 12/10/2020 16:25'!assert: aClassOrInterface behavesLike: interfaces	"Assert that aClassOrInterface behaves like all given interfaces, and only them"	self assert: (aClassOrInterface behavesLike isKindOf: Set).	self assert: (interfaces size) equals: (aClassOrInterface behavesLike size).	interfaces do: [ :each |		self assert: (aClassOrInterface behavesLike includes: each)			description: ('expected ' , aClassOrInterface , ' to behave like ' , each )	].! !!Part2Test methodsFor: 'as yet unclassified' stamp: 'BM 12/10/2020 15:32'!make: parent subclass: name like: behavesLike	^parent subclass: name isInterface: false behavesLike: behavesLike instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.! !!Part2Test methodsFor: 'as yet unclassified' stamp: 'BM 12/10/2020 15:31'!makeInterface: name like: behavesLike	^MyObject subclass: name isInterface: true behavesLike: behavesLike instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.! !!Part2Test methodsFor: 'as yet unclassified' stamp: 'BM 12/9/2020 16:27'!setUp	MyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	A subclass: #B instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	MyObject subclass: #IA isInterface: true behavesLike: {}  instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.	MyObject subclass: #IB isInterface: true behavesLike: {}  instanceVariableNames: '' classVariableNames: '' poolDictionaries: '' category: 'OOP3'.! !