Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'PartB' stamp: 'EK 12/17/2021 13:31'!ambiguities	"get ambigious methods for self class - between behavesLike's intefaces"	| methods |	"We use A bag it's like a set, only it allows multiplicities, and keeps count of recurrence count."	methods := Bag new.	self behavesLike do: [:interface | methods addAll: (interface definedMethods)].	"A method causes ambiguity if it is defined in at least 2 (more then once) interfaces which self behaves like."	"When using a Bag:	Keys = items,   Values = the counts of ocurrences of said item."	^SortedCollection newFrom: ((methods valuesAndCounts select: [:count | count > 1]) keys)! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/17/2021 13:32'!behavesLike	"Get all Interfaces that self behaves like directly or parants (recursively) behave like"		"this implementation works because we built the 'subclass:...' method to include all"	^behavesLike.! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/17/2021 13:47'!isImplemented	"return whether self (which is an Interface) is implemented by some class"		|  |	(self isInterface)		ifFalse: [			AssertionFailure signal: (self name asString , ' is not an interface!!').		].	"Check all of MyObject's subclasses and see whether any of them implement self (which is an interface)"	^MyObject allSubclasses anySatisfy: [:some_sub_class | (some_sub_class isInterface not) and: [self isImplementedBy: some_sub_class]].					! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/17/2021 13:34'!isInterface	"Return whether self is an Interface"	|  |	^(self ~= MyObject) and: [isInterface].! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/12/2021 22:21'!new	"need to override this method to prevent interface instanciation"	(self isInterface)		ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.6)		].	^(super new).! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/17/2021 13:06'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	"This method creates a sublclass which is not an interface and has no new behaviours compared to parent class"	^ (self subclass: aSubclassName isInterface: false behavesLike: (Set new)	instanceVariableNames: instVarNames classVariableNames: classVarNames	poolDictionaries: poolDictionaries category: aCategoryName).! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/17/2021 13:05'!subclass: aSubclassName isInterface: isInterface behavesLike: aCollection instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	"create an Interface or a class"	| young behaviours |		"Checking if user is trying to create an interface that does not inherrit from MyObject"	(((self isMemberOf: MyObject class) not) and: isInterface)		 ifTrue: [ 			AssertionFailure signal: (MyObject getErrorMsg: 2.1).		].	"Checking if user is trying to create an Interface with state"	(((instVarNames isEmpty) not)  and:( isInterface))		 ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.2).		].	"Checking if user is trying to derive a class from an interface"	((isInterface not)  and:  self isInterface)  		ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.3). 		].	"Checking if user is trying declare a behavesLike member which is not an interface"	aCollection do: [ :item | ((item isInterface) not)								ifTrue: [									AssertionFailure signal: (MyObject getErrorMsg: 2.4). 								].					].	"Creating the subclass"	young := (super subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category: aCategoryName).		"Gathering all BeahvesLike interfaces the new subclass should have, including recursive above"	behaviours := aCollection asSet copy.	aCollection do: [:item | behaviours := behaviours union: (item behavesLike).].	behaviours := behaviours union: (self behavesLike).		"an interface behaves like itself"	(isInterface)	ifTrue: [		behaviours add: young.	].	"Setting the subclass's class instance variables"	young instVarNamed: 'behavesLike' put: behaviours.	young instVarNamed: 'isInterface' put: isInterface.	^young.			! !!MyObject class methodsFor: 'PartA' stamp: 'EK 12/17/2021 13:45'!compile: aSourceCode where: anOrderedCollection	"compile sourceCode and verify constraints"	| args first_line_parsed_words lines cnt new_code validation_code local constraint |		lines := aSourceCode lines.	"if there's no constrains - there's no params and so we can skip all the code that follows in the ifTrue"	((anOrderedCollection size) > 0)		ifTrue: [			args := OrderedCollection new.			first_line_parsed_words := (aSourceCode lineNumber: 1) asString findBetweenSubStrs: (' ', ':').			cnt := 1.			"get args names, ther are located at even numbered indexes (after corosponding selector)"			first_line_parsed_words do: [ :itr | (cnt \\ 2 == 1)											ifFalse: [args add: itr.].											cnt := cnt+1.										].			"Number of arguments and constraints given don't match"			( (anOrderedCollection size) == (args size) )				ifFalse: [					AssertionFailure signal: (MyObject getErrorMsg: 1.1). 				].						"Generate the code for checking constraints at runtime"			cnt := 1.			validation_code := ''.			[cnt <= args size]				whileTrue: 				[						((anOrderedCollection at: cnt) ~= nil)						ifTrue: [									constraint := ((anOrderedCollection at: cnt) asString).									local := '(', ((args at: cnt) asString), ' isKindOf: ', constraint, ')', (String cr).									local := local, 'ifFalse: [AssertionFailure signal: ''Type mismatch!! Argument ', (cnt asString), ' should be ' , constraint, '''].', (String cr).									validation_code := validation_code, local.						].					cnt := cnt + 1.				].									"Combine the constraints checking code with the original code"			((lines size >= 2) and: [(lines at: 2) withoutLeadingBlanks beginsWith: '|'])				ifTrue: [					new_code := ((lines at: 1), (String cr), (lines at: 2), (String cr), validation_code).					cnt := 3.				]				ifFalse: [					new_code := ((lines at: 1), (String cr), validation_code).					cnt := 2.				].			[cnt <= lines size]				whileTrue: 				[						new_code := new_code, (String cr), (lines at: cnt).					cnt := cnt+1.				]		]					ifFalse: [			new_code := aSourceCode.		].		"Added this to ensure that the user is not compiling a non-emty method to an interface"	(self isInterface and: (lines size > 1))		ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.7).		].		^super compile: new_code.	! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/12/2021 21:36'!definedMethods	"Return all methods defined by self.	Does not include methods defined in other classes/interfaces that self derives from/behaves like."	(self = MyObject) ifTrue: [^Set new].	^Set newFrom: (self methodDict keys)! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/17/2021 12:04'!getErrorMsg: errorCode	"get error message coresponding to error code requested"	| switch |	switch := Dictionary new.	switch at: 1.1 put: 'Can not compile method, number of arguments is not equal to the number of constraints!!'.	switch at: 1.2 put: 'Type mismatch!! Argument #NUMBER should be #CLASS'.	switch at: 2.1 put: 'Interfaces must derive from MyObject!!'.	switch at: 2.2 put: 'Interfaces can not have state!!'.	switch at: 2.3 put: 'Classes can not derive from an interface!!'.	switch at: 2.4 put: 'Can not behave like a non-interface!!'.	switch at: 2.5 put: '#CLASS is not an interface!!'.	switch at: 2.6 put: 'Interfaces can not be instantiated!!'.	switch at: 2.7 put: 'Interfaces are not allowed to have methods that define behavior!!'.		^ switch at: errorCode		! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/17/2021 13:24'!implementsMethod: aSymbol	"Return true if self implements method whose name is aSymbol"	(self canUnderstand: aSymbol) ifTrue: [^true].	"Stop condition for the recursion"	(self = MyObject) ifTrue: [^false].	^superclass implementsMethod: aSymbol! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/17/2021 13:53'!isImplementedBy: aClass	"return whether the interface is implemented by this specific class"	| interfaceMethods |		interfaceMethods := Set new.	"Gather all methods required by the interface and all interfaces it behves like"	behavesLike do: [:interf |						interfaceMethods addAll: interf methodDict keys.					].	"if aClass does not behave like self(interface) then by the HW properties, it does not implement it"	(aClass behavesLike includes: self)		ifFalse: [			^false.		]		ifTrue: [			"Check that all methods of self (an interface) are implemented by aClass or it's parents"			^interfaceMethods allSatisfy: [:meth | aClass implementsMethod: meth].		].! !MyObject subclass: #A	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!A methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:25'!bar! !!A methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:35'!baz! !!A methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:37'!foo||Transcript show: 123; cr.! !MyObject subclass: #AB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #B	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!A subclass: #D	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!D subclass: #E	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!E methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:39'!foobar||Transcript show: 333; cr.! !E subclass: #F	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!F subclass: #G	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #IA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!IA methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:20'!bar! !!IA methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:26'!baz! !!IA methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:01'!foo! !!IA methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:39'!foobar! !!IA methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 13:49'!foobar:a baz:b! !MyObject subclass: #IAA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #IB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!IB methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:06'!bar! !MyObject subclass: #IC	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #ID	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #IF	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!IF methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 13:49'!foobar:a baz:b! !