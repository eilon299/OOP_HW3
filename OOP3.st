Object subclass: #MyObject	instanceVariableNames: 'behavesLike isInterface'	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'initialize-release' stamp: 'EK 12/12/2021 12:47'!initialize	behavesLike := Set new.! !!MyObject methodsFor: 'as yet unclassified' stamp: 'EK 12/12/2021 14:25'!foo: a bar: b baz: c | var1 | (a isKindOf: Integer)ifFalse: [AssertionFailure signal: 'Type mismatch!! Argument 1 should be Integer'].(c isKindOf: Number)ifFalse: [AssertionFailure signal: 'Type mismatch!! Argument 3 should be Number'].var1 := a + c + (2 * b)."just a comment, nothing special" ^ (var1 * var1)! !!MyObject methodsFor: 'as yet unclassified' stamp: 'EK 12/11/2021 19:05'!method1| |Transcript show:1.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: ''!!MyObject class methodsFor: 'PartB' stamp: 'EK 12/12/2021 14:14'!ambiguities	"comment stating purpose of message"	| |! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/12/2021 14:12'!behavesLike	"comment stating purpose of message"	|  |	^ self behavesLike.! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/12/2021 20:55'!isImplemented	"comment stating purpose of message"		| |	(self isInterface)		ifFalse: [			AssertionFailure signal: (self class name asString , ' is not an interface!!').		].		"TODO missing imp!!"						! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/12/2021 14:09'!isInterface	"comment stating purpose of message"	|  |	^ self isInterface.! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/12/2021 22:21'!new	"need to override this method to prevent interface instanciation"	(self isInterface)		ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.6)		].	^(super new).! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/12/2021 22:13'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	^ (self subclass: aSubclassName isInterface: false behavesLike: (Set new)	instanceVariableNames: instVarNames classVariableNames: classVarNames	poolDictionaries: poolDictionaries category: aCategoryName).! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/12/2021 21:38'!subclass: aSubclassName isInterface: isInterface behavesLike: aCollection instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	"create an Interface or a class that might implement interfaces			if it is an interface, add itself to behavesLike field"	| anInstance |		(((self isMemberOf: MyObject class) not) and: isInterface)		 ifTrue: [ 			AssertionFailure signal: (MyObject getErrorMsg: 2.1).		].		(((instVarNames isEmpty) not)  and:( isInterface))		 ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.2).		].		((isInterface not)  and:  self isInterface)  		ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.3). 		].		aCollection do: [ :item | ((item isInterface) not)								ifTrue: [									AssertionFailure signal: (MyObject getErrorMsg: 2.4). 								].					].		anInstance := (super subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category: aCategoryName).	anInstance instVarNamed: #isInterface put: isInterface.		(isInterface)	ifTrue: [		anInstance instVarNamed: #behavesLike put: (aCollection copyWith: aSubclassName) asSet.	]	ifFalse: [		anInstance instVarNamed: #behavesLike put: (aCollection copy) asSet.		anInstance injectDefaultMethods.	].	^anInstance.			! !!MyObject class methodsFor: 'PartA' stamp: 'EK 12/12/2021 20:14'!compile: aSourceCode where: anOrderedCollection	"compile sourceCode and verify constraints"	| args selectors first_line parsed_line lines cnt new_code validation_code local constraint |		selectors := OrderedCollection new.	lines := aSourceCode lines.	"if there's no constrains - there's no params and so we can skip this"	((anOrderedCollection size) > 0)		ifTrue: [			args := OrderedCollection new.			first_line := (aSourceCode lineNumber: 1).			parsed_line := first_line asString findBetweenSubStrs: (' ', ':').			cnt := 1.						parsed_line do: [ :itr | (cnt \\ 2 == 1)								ifTrue: [selectors add: itr.]								ifFalse: [args add: itr.].								cnt := cnt+1.							].			( (anOrderedCollection size) == (args size) )				ifFalse: [					AssertionFailure signal: (MyObject getErrorMsg: 1.1). 				].							cnt := 1.			validation_code := ''.			[cnt <= args size]				whileTrue: 				[						((anOrderedCollection at: cnt) ~= nil)						ifTrue: [									constraint := ((anOrderedCollection at: cnt) asString).									local := '(', ((args at: cnt) asString), ' isKindOf: ', constraint, ')', (String cr).									local := local, 'ifFalse: [AssertionFailure signal: ''Type mismatch!! Argument ', (cnt asString), ' should be ' , constraint, '''].', (String cr).									validation_code := validation_code, local.						].					cnt := cnt + 1.				].												((lines size >= 2) and: [(lines at: 2) withoutLeadingBlanks beginsWith: '|'])				ifTrue: [					new_code := ((lines at: 1), (String cr), (lines at: 2), (String cr), validation_code).					cnt := 3.				]				ifFalse: [					new_code := ((lines at: 1), (String cr), validation_code).					cnt := 2.				].						[cnt <= lines size]				whileTrue: 				[						new_code := new_code, (String cr), (lines at: cnt).					cnt := cnt+1.				]		]					ifFalse: [			new_code := aSourceCode.		].		^super compile: new_code.						"Transcript show: selectors asArray; cr.		Transcript show: args asArray; cr."	! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/12/2021 21:36'!definedMethods	"Return all methods defined by self.	Does not include methods defined in other classes/interfaces that self derives from/behaves like."	(self = MyObject) ifTrue: [^Set new].	^Set newFrom: (self methodDict keys)! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/12/2021 20:12'!getErrorMsg: errorCode	"get error message coresponding to error code requested"	| switch |	switch := Dictionary new.	switch at: 1.1 put: 'Can not compile method, number of arguments is not equal to the number of constraints!!'.	switch at: 1.2 put: 'Type mismatch!! Argument #NUMBER should be #CLASS'.	switch at: 2.1 put: 'Interfaces must derive from MyObject!!'.	switch at: 2.2 put: 'Interfaces can not have state!!'.	switch at: 2.3 put: 'Classes can not derive from an interface!!'.	switch at: 2.4 put: 'Can not behave like a non-interface!!'.	switch at: 2.5 put: '#CLASS is not an interface!!'.	switch at: 2.6 put: 'Interfaces can not be instantiated!!'.	switch at: 2.7 put: 'Interfaces are not allowed to have methods that define behavior!!'.	switch at: 3.1 put: 'Can not instantiate an Abstract class!!'.		^ switch at: errorCode		! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/12/2021 21:38'!injectDefaultMethods	"Inject into self all the default methods defined in classes it behaves like."	self behavesLike do: [:interface |							interface definedMethods								select: [:each | each beginsWith: 'default']								thenDo: [:method | self injectMethod: method from: interface]						].! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/12/2021 21:38'!injectMethod: aMethodName from: aClass	"Inject into self a method defined in aClass.	The method is injected into self by compiling a new method into self.	The new method	creates a new instance of aClass, then invokes its method and returns the result."	| selector new_code |	selector := (aClass methodDict at: aMethodName) selector.		(selector endsWith: ':') 		ifTrue: [			"Method has arguments. Assume it only has one, an Integer."			"New code: 'foo: x\n^(aClass privateNew) foo: x'"			"We use privateNew instead of new, to by-pass abstractness/interfaceness restrictions.			This is okay, because the instance is not visible outside of the method."			new_code := '' , selector , ' x' , (String cr) , '^(' , aClass , ' privateNew) ' , selector , ' x'.		] 		ifFalse: [			"Methtod has 0 argument"			"New code: 'foo\n^(aClass privateNew) foo'"			new_code := '' , selector , (String cr) , '^(' , aClass , ' privateNew) ' , selector		].	self compile: new_code.! !