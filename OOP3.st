Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject methodsFor: 'as yet unclassified' stamp: 'EK 12/15/2021 20:07'!foo: a bar: b baz: c||(a isKindOf: Integer)ifFalse: [AssertionFailure signal: 'Type mismatch!! Argument 1 should be Integer'].(c isKindOf: Number)ifFalse: [AssertionFailure signal: 'Type mismatch!! Argument 3 should be Number'].! !!MyObject methodsFor: 'as yet unclassified' stamp: 'EK 12/11/2021 19:05'!method1| |Transcript show:1.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'PartB' stamp: 'EK 12/15/2021 20:14'!ambiguities	| methods |	"A bag is actually a set that allows multiplicities, and keeps count how many times each	item occurres in the set."	methods := Bag new.	self behavesLike do: [:interface | methods addAll: (interface definedMethods)].	"A method causes ambiguity if it is defined in at least 2 interfaces whom self behaves like. 	These are exactly the methods that appear at least twice in the bag."	"Naming is misleading here - valuesAndCounts returns a dictionary. The keys of the dictionary are	the values (items) of the bag, and the values of the dictionary are the counts of the bag."	^SortedCollection newFrom: ((methods valuesAndCounts select: [:count | count > 1]) keys)! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/15/2021 18:37'!behavesLike	"comment stating purpose o	f message"	^behavesLike.! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/15/2021 20:38'!isImplemented	"comment stating purpose of message"		|  |	(self isInterface)		ifFalse: [			AssertionFailure signal: (self class name asString , ' is not an interface!!').		].		^MyObject allSubclasses anySatisfy: [:any | (any isInterface not) and: [self isImplementedBy: any]].					! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/15/2021 17:35'!isInterface	"comment stating purpose of message"	|  |	^(self ~= MyObject) and: [isInterface].! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/12/2021 22:21'!new	"need to override this method to prevent interface instanciation"	(self isInterface)		ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.6)		].	^(super new).! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/12/2021 22:13'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	^ (self subclass: aSubclassName isInterface: false behavesLike: (Set new)	instanceVariableNames: instVarNames classVariableNames: classVarNames	poolDictionaries: poolDictionaries category: aCategoryName).! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/15/2021 19:04'!subclass: aSubclassName isInterface: isInterface behavesLike: aCollection instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	"create an Interface or a class that might implement interfaces			if it is an interface, add itself to behavesLike field"	| young behaviours |		(((self isMemberOf: MyObject class) not) and: isInterface)		 ifTrue: [ 			AssertionFailure signal: (MyObject getErrorMsg: 2.1).		].		(((instVarNames isEmpty) not)  and:( isInterface))		 ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.2).		].		((isInterface not)  and:  self isInterface)  		ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.3). 		].		aCollection do: [ :item | ((item isInterface) not)								ifTrue: [									AssertionFailure signal: (MyObject getErrorMsg: 2.4). 								].					].		young := (super subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category: aCategoryName).		behaviours := aCollection asSet copy.	aCollection do: [:item | behaviours := behaviours union: (item behavesLike).].	behaviours := behaviours union: (self behavesLike).		(isInterface)	ifTrue: [		behaviours add: young.		"anInstance injectDefaultMethods."	].	young instVarNamed: 'behavesLike' put: behaviours.	young instVarNamed: 'isInterface' put: isInterface.	^young.			! !!MyObject class methodsFor: 'PartA' stamp: 'EK 12/15/2021 20:08'!compile: aSourceCode where: anOrderedCollection	"compile sourceCode and verify constraints"	| args selectors first_line parsed_line lines cnt new_code validation_code local constraint |		selectors := OrderedCollection new.	lines := aSourceCode lines.	"if there's no constrains - there's no params and so we can skip this"	((anOrderedCollection size) > 0)		ifTrue: [			args := OrderedCollection new.			first_line := (aSourceCode lineNumber: 1).			parsed_line := first_line asString findBetweenSubStrs: (' ', ':').			cnt := 1.						parsed_line do: [ :itr | (cnt \\ 2 == 1)								ifTrue: [selectors add: itr.]								ifFalse: [args add: itr.].								cnt := cnt+1.							].			( (anOrderedCollection size) == (args size) )				ifFalse: [					AssertionFailure signal: (MyObject getErrorMsg: 1.1). 				].							cnt := 1.			validation_code := ''.			[cnt <= args size]				whileTrue: 				[						((anOrderedCollection at: cnt) ~= nil)						ifTrue: [									constraint := ((anOrderedCollection at: cnt) asString).									local := '(', ((args at: cnt) asString), ' isKindOf: ', constraint, ')', (String cr).									local := local, 'ifFalse: [AssertionFailure signal: ''Type mismatch!! Argument ', (cnt asString), ' should be ' , constraint, '''].', (String cr).									validation_code := validation_code, local.						].					cnt := cnt + 1.				].												((lines size >= 2) and: [(lines at: 2) withoutLeadingBlanks beginsWith: '|'])				ifTrue: [					new_code := ((lines at: 1), (String cr), (lines at: 2), (String cr), validation_code).					cnt := 3.				]				ifFalse: [					new_code := ((lines at: 1), (String cr), validation_code).					cnt := 2.				].			[cnt <= lines size]				whileTrue: 				[						new_code := new_code, (String cr), (lines at: cnt).					cnt := cnt+1.				]		]					ifFalse: [			new_code := aSourceCode.		].		(self isInterface and: (lines size > 1))		ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.7).		].		^super compile: new_code.	! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/12/2021 21:36'!definedMethods	"Return all methods defined by self.	Does not include methods defined in other classes/interfaces that self derives from/behaves like."	(self = MyObject) ifTrue: [^Set new].	^Set newFrom: (self methodDict keys)! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/12/2021 20:12'!getErrorMsg: errorCode	"get error message coresponding to error code requested"	| switch |	switch := Dictionary new.	switch at: 1.1 put: 'Can not compile method, number of arguments is not equal to the number of constraints!!'.	switch at: 1.2 put: 'Type mismatch!! Argument #NUMBER should be #CLASS'.	switch at: 2.1 put: 'Interfaces must derive from MyObject!!'.	switch at: 2.2 put: 'Interfaces can not have state!!'.	switch at: 2.3 put: 'Classes can not derive from an interface!!'.	switch at: 2.4 put: 'Can not behave like a non-interface!!'.	switch at: 2.5 put: '#CLASS is not an interface!!'.	switch at: 2.6 put: 'Interfaces can not be instantiated!!'.	switch at: 2.7 put: 'Interfaces are not allowed to have methods that define behavior!!'.	switch at: 3.1 put: 'Can not instantiate an Abstract class!!'.		^ switch at: errorCode		! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/15/2021 20:32'!implementsMethod: aSymbol	"Return true if self implements method whose name is aSymbol"	(self canUnderstand: aSymbol) ifTrue: [^true].	(self = MyObject) ifTrue: [^false].	^superclass implementsMethod: aSymbol! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/12/2021 21:38'!injectDefaultMethods	"Inject into self all the default methods defined in classes it behaves like."	self behavesLike do: [:interface |							interface definedMethods								select: [:each | each beginsWith: 'default']								thenDo: [:method | self injectMethod: method from: interface]						].! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/12/2021 21:38'!injectMethod: aMethodName from: aClass	"Inject into self a method defined in aClass.	The method is injected into self by compiling a new method into self.	The new method	creates a new instance of aClass, then invokes its method and returns the result."	| selector new_code |	selector := (aClass methodDict at: aMethodName) selector.		(selector endsWith: ':') 		ifTrue: [			"Method has arguments. Assume it only has one, an Integer."			"New code: 'foo: x\n^(aClass privateNew) foo: x'"			"We use privateNew instead of new, to by-pass abstractness/interfaceness restrictions.			This is okay, because the instance is not visible outside of the method."			new_code := '' , selector , ' x' , (String cr) , '^(' , aClass , ' privateNew) ' , selector , ' x'.		] 		ifFalse: [			"Methtod has 0 argument"			"New code: 'foo\n^(aClass privateNew) foo'"			new_code := '' , selector , (String cr) , '^(' , aClass , ' privateNew) ' , selector		].	self compile: new_code.! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/15/2021 20:34'!isImplementedBy: aClass	"return whether the interface is implemented by this specific class"	| interfaceMethods |	(self = MyObject) ifTrue: [^Set new].	interfaceMethods := Set new.	(behavesLike select: [:each | each isInterface])		do: [:each | interfaceMethods addAll: each methodDict keys].				(aClass behavesLike includes: self)		ifFalse: [			^false.		]		ifTrue: [			^interfaceMethods allSatisfy: [:each | aClass implementsMethod: each].		].! !MyObject subclass: #A	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #B	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!B methodsFor: 'as yet unclassified' stamp: 'EK 12/15/2021 19:09'!foo! !!B methodsFor: 'as yet unclassified' stamp: 'EK 12/15/2021 19:10'!foo: a(a isKindOf: Integer)ifFalse: [AssertionFailure signal: 'Type mismatch!! Argument 1 should be Integer'].! !A subclass: #C	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #IA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #IB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!