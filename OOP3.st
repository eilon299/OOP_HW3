Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'PartB' stamp: 'EK 12/15/2021 20:14'!ambiguities	| methods |	"A bag is actually a set that allows multiplicities, and keeps count how many times each	item occurres in the set."	methods := Bag new.	self behavesLike do: [:interface | methods addAll: (interface definedMethods)].	"A method causes ambiguity if it is defined in at least 2 interfaces whom self behaves like. 	These are exactly the methods that appear at least twice in the bag."	"Naming is misleading here - valuesAndCounts returns a dictionary. The keys of the dictionary are	the values (items) of the bag, and the values of the dictionary are the counts of the bag."	^SortedCollection newFrom: ((methods valuesAndCounts select: [:count | count > 1]) keys)! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/15/2021 18:37'!behavesLike	"comment stating purpose o	f message"	^behavesLike.! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/17/2021 12:00'!isImplemented	"comment stating purpose of message"		|  |	(self isInterface)		ifFalse: [			AssertionFailure signal: (self name asString , ' is not an interface!!').		].		^MyObject allSubclasses anySatisfy: [:any | (any isInterface not) and: [self isImplementedBy: any]].					! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/15/2021 17:35'!isInterface	"comment stating purpose of message"	|  |	^(self ~= MyObject) and: [isInterface].! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/12/2021 22:21'!new	"need to override this method to prevent interface instanciation"	(self isInterface)		ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.6)		].	^(super new).! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/12/2021 22:13'!subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	^ (self subclass: aSubclassName isInterface: false behavesLike: (Set new)	instanceVariableNames: instVarNames classVariableNames: classVarNames	poolDictionaries: poolDictionaries category: aCategoryName).! !!MyObject class methodsFor: 'PartB' stamp: 'EK 12/17/2021 11:36'!subclass: aSubclassName isInterface: isInterface behavesLike: aCollection instanceVariableNames: instVarNames classVariableNames: classVarNames poolDictionaries: poolDictionaries category: aCategoryName	"create an Interface or a class that might implement interfaces			if it is an interface, add itself to behavesLike field"	| young behaviours |		(((self isMemberOf: MyObject class) not) and: isInterface)		 ifTrue: [ 			AssertionFailure signal: (MyObject getErrorMsg: 2.1).		].		(((instVarNames isEmpty) not)  and:( isInterface))		 ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.2).		].		((isInterface not)  and:  self isInterface)  		ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.3). 		].		aCollection do: [ :item | ((item isInterface) not)								ifTrue: [									AssertionFailure signal: (MyObject getErrorMsg: 2.4). 								].					].		young := (super subclass: aSubclassName instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category: aCategoryName).		behaviours := aCollection asSet copy.	aCollection do: [:item | behaviours := behaviours union: (item behavesLike).].	behaviours := behaviours union: (self behavesLike).		(isInterface)	ifTrue: [		behaviours add: young.	].	young instVarNamed: 'behavesLike' put: behaviours.	young instVarNamed: 'isInterface' put: isInterface.	^young.			! !!MyObject class methodsFor: 'PartA' stamp: 'EK 12/15/2021 20:08'!compile: aSourceCode where: anOrderedCollection	"compile sourceCode and verify constraints"	| args selectors first_line parsed_line lines cnt new_code validation_code local constraint |		selectors := OrderedCollection new.	lines := aSourceCode lines.	"if there's no constrains - there's no params and so we can skip this"	((anOrderedCollection size) > 0)		ifTrue: [			args := OrderedCollection new.			first_line := (aSourceCode lineNumber: 1).			parsed_line := first_line asString findBetweenSubStrs: (' ', ':').			cnt := 1.						parsed_line do: [ :itr | (cnt \\ 2 == 1)								ifTrue: [selectors add: itr.]								ifFalse: [args add: itr.].								cnt := cnt+1.							].			( (anOrderedCollection size) == (args size) )				ifFalse: [					AssertionFailure signal: (MyObject getErrorMsg: 1.1). 				].							cnt := 1.			validation_code := ''.			[cnt <= args size]				whileTrue: 				[						((anOrderedCollection at: cnt) ~= nil)						ifTrue: [									constraint := ((anOrderedCollection at: cnt) asString).									local := '(', ((args at: cnt) asString), ' isKindOf: ', constraint, ')', (String cr).									local := local, 'ifFalse: [AssertionFailure signal: ''Type mismatch!! Argument ', (cnt asString), ' should be ' , constraint, '''].', (String cr).									validation_code := validation_code, local.						].					cnt := cnt + 1.				].												((lines size >= 2) and: [(lines at: 2) withoutLeadingBlanks beginsWith: '|'])				ifTrue: [					new_code := ((lines at: 1), (String cr), (lines at: 2), (String cr), validation_code).					cnt := 3.				]				ifFalse: [					new_code := ((lines at: 1), (String cr), validation_code).					cnt := 2.				].			[cnt <= lines size]				whileTrue: 				[						new_code := new_code, (String cr), (lines at: cnt).					cnt := cnt+1.				]		]					ifFalse: [			new_code := aSourceCode.		].		(self isInterface and: (lines size > 1))		ifTrue: [			AssertionFailure signal: (MyObject getErrorMsg: 2.7).		].		^super compile: new_code.	! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/12/2021 21:36'!definedMethods	"Return all methods defined by self.	Does not include methods defined in other classes/interfaces that self derives from/behaves like."	(self = MyObject) ifTrue: [^Set new].	^Set newFrom: (self methodDict keys)! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/17/2021 12:04'!getErrorMsg: errorCode	"get error message coresponding to error code requested"	| switch |	switch := Dictionary new.	switch at: 1.1 put: 'Can not compile method, number of arguments is not equal to the number of constraints!!'.	switch at: 1.2 put: 'Type mismatch!! Argument #NUMBER should be #CLASS'.	switch at: 2.1 put: 'Interfaces must derive from MyObject!!'.	switch at: 2.2 put: 'Interfaces can not have state!!'.	switch at: 2.3 put: 'Classes can not derive from an interface!!'.	switch at: 2.4 put: 'Can not behave like a non-interface!!'.	switch at: 2.5 put: '#CLASS is not an interface!!'.	switch at: 2.6 put: 'Interfaces can not be instantiated!!'.	switch at: 2.7 put: 'Interfaces are not allowed to have methods that define behavior!!'.		^ switch at: errorCode		! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/15/2021 20:32'!implementsMethod: aSymbol	"Return true if self implements method whose name is aSymbol"	(self canUnderstand: aSymbol) ifTrue: [^true].	(self = MyObject) ifTrue: [^false].	^superclass implementsMethod: aSymbol! !!MyObject class methodsFor: 'utils' stamp: 'EK 12/15/2021 20:34'!isImplementedBy: aClass	"return whether the interface is implemented by this specific class"	| interfaceMethods |	(self = MyObject) ifTrue: [^Set new].	interfaceMethods := Set new.	(behavesLike select: [:each | each isInterface])		do: [:each | interfaceMethods addAll: each methodDict keys].				(aClass behavesLike includes: self)		ifFalse: [			^false.		]		ifTrue: [			^interfaceMethods allSatisfy: [:each | aClass implementsMethod: each].		].! !MyObject subclass: #A	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!A methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:25'!bar! !!A methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:35'!baz! !!A methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:37'!foo||Transcript show: 123; cr.! !MyObject subclass: #AB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #B	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!A subclass: #D	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!D subclass: #E	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!E methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:39'!foobar||Transcript show: 333; cr.! !E subclass: #F	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!F subclass: #G	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #IA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!IA methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:20'!bar! !!IA methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:26'!baz! !!IA methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:01'!foo! !!IA methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:39'!foobar! !MyObject subclass: #IAA	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #IB	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!IB methodsFor: 'as yet unclassified' stamp: 'EK 12/17/2021 12:06'!bar! !MyObject subclass: #IC	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #ID	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!MyObject subclass: #IF	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!